

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>
<meta name="baidu-site-verification" content="code-pWYHJ937vm" />



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#252d38">
  <meta name="description" content="">
  <meta name="author" content="Tenny">
  <meta name="keywords" content="">
  <meta name="description" content="原文链接：https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;8806731?denied&#x3D; ​ https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;xpl&#x2F;conhome&#x2F;8790377&#x2F;proceeding 发表会议： 2019 年 IEEE 欧洲安全和隐私研讨会 （EuroS&amp;P）  摘要 ​ 鉴于 Android 框架的频繁变化和 Andro">
<meta property="og:type" content="article">
<meta property="og:title" content="DroidEvolver -- Self-Evolving Android Malware Detection System">
<meta property="og:url" content="https://tennybupt.github.io/2021/11/16/DroidEvolver/index.html">
<meta property="og:site_name" content="Tenny&#39;s World">
<meta property="og:description" content="原文链接：https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;document&#x2F;8806731?denied&#x3D; ​ https:&#x2F;&#x2F;ieeexplore.ieee.org&#x2F;xpl&#x2F;conhome&#x2F;8790377&#x2F;proceeding 发表会议： 2019 年 IEEE 欧洲安全和隐私研讨会 （EuroS&amp;P）  摘要 ​ 鉴于 Android 框架的频繁变化和 Andro">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu1-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t1-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu2-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t2-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu3-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu4-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu6-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu8-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu7-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu10-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu9-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu11-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t3-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t4-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t5-p16-xu-small.gif">
<meta property="og:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu12-p16-xu-small.gif">
<meta property="article:published_time" content="2021-11-16T09:30:00.000Z">
<meta property="article:modified_time" content="2021-11-18T08:24:00.074Z">
<meta property="article:author" content="Tenny">
<meta property="article:tag" content="Android Malware">
<meta property="article:tag" content="论文翻译">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu1-p16-xu-small.gif">
  
  <title>DroidEvolver -- Self-Evolving Android Malware Detection System - Tenny&#39;s World</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/font.css">
<link rel="stylesheet" href="/css/scrollbar.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"tennybupt.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Tenny's World" type="application/atom+xml">
</head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tenny&#39;s World</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner/droidevolved.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="DroidEvolver -- Self-Evolving Android Malware Detection System">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-16 17:30" pubdate>
        2021年11月16日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      84 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">DroidEvolver -- Self-Evolving Android Malware Detection System</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 小时前
                
              </p>
            
            <div class="markdown-body">
              <blockquote>
<p>原文链接：https://ieeexplore.ieee.org/document/8806731?denied=</p>
<p>​ https://ieeexplore.ieee.org/xpl/conhome/8790377/proceeding</p>
<p>发表会议： 2019 年 IEEE 欧洲安全和隐私研讨会 （EuroS&amp;P）</p>
</blockquote>
<h2 id="摘要">摘要</h2>
<p>​ 鉴于 <strong>Android 框架的频繁变化和 Android 恶意软件的不断发展</strong>，随着时间的推移，以有效且可扩展的方式检测恶意软件是具有挑战性的。</p>
<p>​ 为了应对这一挑战，我们提出了<strong>DrodEvolver</strong>，这是一个Android恶意软件检测系统，可以在恶意软件检测过程中自动和持续地更新自己，而无需任何人参与。虽然大多数现有的恶意软件检测系统可以通过对带有真实标签的新应用程序进行再训练来更新，但 <strong>DroidEvolver 既不需要再训练，也不需要真实标签来更新自己</strong>，这主要是因为 DroidEvolver 使用<strong>具有不断发展的特征集和伪标签的在线学习技术进行必要和轻量级的更新</strong>。在六年内开发的 33,294 个良性应用程序和 34,722 个恶意应用程序的数据集上评估了 DroidEvolver 的检测表现。</p>
<p>​ 使用 2011 年的6,286个应用程序作为初始训练集，DroidEvolver 实现了高检测 F-score（95.27%），对于57,539个新出现的应用进行分类，未来五年平均每年仅下降1.06%。请注意，此类新应用程序可以使用新技术和新的 API，在 2011 年应用启动时，DroidEvolver 不知道这些技术和 API。与目前最先进的恶意软件检测系统 MamaDroid 相比，DroidEvolver的 F-score 平均高2.19 倍（第五年高10.21倍），DroidEvolver 在恶意软件检测中的效率比 MamaDroid 高 28.58 倍，DroidEvolver 也显示对典型的代码混淆技术强健。</p>
<h2 id="介绍">1、介绍</h2>
<p>​ <strong>Android 应用程序和 Android 框架都随着时间的推移不断演变，原因多种多样，如特征增强和 bug 修复</strong>。因此，构建 Android 恶意软件检测系统变得越来越困难，这些系统经过旧的 Android 应用程序训练，在操作一段时间后能够有效且可扩展地检测新应用程序中的恶意软件。现有的Android检测系统的快速老化引起了业界和学术界的极大关注。在 BlaixHat 2016 中指出，百度开发的恶意软件检测系统的召回率在六个月内下降了7.6%。在研究文献中，最近通过 API 抽象使恶意软件检测适应 API 更改，但是，恶意软件检测的老化问题尚未完全解决。</p>
<p>​ 为了使恶意软件检测准确，<strong>大多数恶意软件检测系统需要及时和重复地使用新应用程序进行再训练</strong>。然而，这种解决办法面临若干挑战。</p>
<ul>
<li>首先，<strong>很难确定何时重新训练恶意软件检测系统</strong>，如果系统再训练过于频繁，则会导致资源浪费，而不提供新信息来丰富检测系统，否则，检测系统无法及时捕获某些新的恶意软件。</li>
<li>其次，<strong>再训练过程需要对所有经过处理的新应用程序进行手动标记</strong>，这受制于可用资源。手动标签的高成本通常会导致再训练周期较长，因此，检测表现会受到影响。</li>
<li>最后，大多数现有的恶意软件检测系统都进行了累积数据集的重新训练，包括原始训练数据集和新标记的应用程序。这种<strong>再训练过程成本高昂且无法扩展</strong>，尤其是在新应用数量随着时间而快速增长的情况下。</li>
</ul>
<p>​ 为了应对这些挑战，我们提出了一种名为 DroidEvolver 的新型自我进化的 Android 恶意软件检测系统，通过对其具有不断发展的特征集的检测模型进行必要的更新，使恶意软件检测随着时间的推移准确无误。DroidEvolver 维护着一组使用各种在线学习算法使用标记应用程序初始化的不同检测模型的模型池。维护模型池的原因是，不同的检测模型不太可能以相同的速度老化恶意软件检测，即使它们是用相同的数据集初始化的。在检测阶段，在”年轻“检测模型中进行加权投票，根据其 Android API 调用对每个应用程序进行分类。<strong>DroidEvolver 提取 Android API 调用作为检测特征</strong>，因为它们自然而然地反映了 Android 框架和应用程序的演变，并且它们可以轻松地从字节代码中提取，以便高效检测恶意软件。</p>
<p>​ <strong>检测应用程序的“年轻”模型根据<em>聚文化指示器</em>（JI） 确定</strong>，该指标是根据检测到的应用程序与检测模型分类为同一预测标签的一批应用程序之间的相似性来计算的。如果检测模型因检测到的应用程序而老化，DroidEvolver 会使用检测到的应用程序及其由模型池生成的分类结果（即伪标签）更新该模型。DroidEvolver还更新其特征集，以适应从应用程序中发现的 API 更改。</p>
<p>​ <strong>DroidEvolver使用 JI 来确定何时更新其特征集和每个检测模型</strong>。可以计算每个检测模型和检测到的每个新应用程序的 JI。如果 JI 属于一定范围，则相应的检测模型视为<em>老化模型。</em>如果模型池中的任何模型老化以检测此应用程序，则检测到的应用程序将识别为<em>漂移</em>应用程序。老化模型对漂移应用程序进行分类有局限性，其中可能包括新的 API 调用或新的 API 使用模式。因此，一旦识别漂移应用程序，DroidEvolver 将更新其特征集和所有老化模型。</p>
<p>​ 在恶意软件检测中更新其模型池时，<strong>DroidEvolver 不需要任何经过处理的应用程序的真实标签</strong>。这使得不必在DroidEvolver 初始化后对任何应用程序再进行手动标记，从而减少了DroidEvolver的资源和成本限制。在识别漂移应用程序的情况下，<strong>DroidEvolver 会为漂移应用程序生成一个伪标签，并在进入下一个应用程序之前根据漂移应用程序及其伪标签更新所有老化模型</strong>。如果当前应用程序不是漂移应用程序（因此没有识别老化模型），则模型池中的所有模型都有助于分类结果，并且不执行模型更新。</p>
<p>​ 随着时间的推移，<strong>DroidEvolver对于恶意软件检测非常有效</strong>。初始化后，它不需要定期对累积数据集进行任何再训练；相反，每当识别和处理单个漂移应用程序时，它就会高效演变，除非在这种情况下所有模型都在老化。为此，模型池中的所有检测模型都使用在线学习算法进行初始化，该算法可以通过流式传输数据执行增量学习。与批量学习算法相比，在线学习算法更高效、更可扩展，<strong>因为它们不仅避免了初始阶段原始训练数据集的批量处理，还避免了检测阶段累积数据集的定期再训练</strong>。虽然现有的在线学习算法仅与标记数据配合使用，但 DroidEvolver 使它们与检测阶段与伪标签相关的应用程序配合使用。与现有的在线学习方法不同，DroidEvolver 仅针对每个漂移应用程序更新每个应用程序的老化模型，从而更新每个应用的检测模型。在更新过程中，DroidEvolver 不需要任何真实标签与漂移应用程序相关联。从这个意义上说，DroidEvolver 比现有的基于在线学习的方法更实用。因此，在必要时，老化模型会迅速被重新确定。这进一步促进了DroidEvolver的效率。</p>
<p>​ DroidEvolver 通过一系列数据集进行严格评估，包括 2011 年至 2016 年 34,722 个恶意应用程序和 33,294 个良性应用程序。DroidEvolver的功效和效率与 MamaDroid 相比（MamaDroid 是一种最先进的恶意软件检测系统），可抵御 API 随时间的变化。在DroidEvolver 和 MamaDroid 在同一时期开发的相同应用中接受训练和测试的情况下，DroidEvolver 显著优于 MamaDroid ，在我们的实验中，F-score 提高了 15.80%，精度提高了 12.97%，召回率平均提高了 17.57%。在一到五年内对比训练套数较新的测试组进行评估时，DroidEvolver 的平均 F-score 分别为92.32%、89.30%、87.17%、87.46% 和 89.97%。相比之下，在相应情况下，MamaDroid 的平均 F-score 分别为68.01%、56.09%、45.88%、32.85% 和 8.81%。随着时间的推移，DroidEvolver 的整体 F-score 比 MamaDroid 的平均值高出 2.11 倍。五年来，DroidEvolver的 F-score 平均每年下降1.06%，而MamaDroid 在相同情况下每年平均下降13.52%。此外，如果只有少量带有真实标签的数据更新了F-score，DroidEvolver 将其 F-score 保持在较高水平，而在这种情况下，MamaDroid 的 F-score 每年都会下降。</p>
<p>​ 然后，我们评估DroidEvolver的效率，并将其与 MamaDroid 进行比较。DroidEvolver 的初始化需要线性时间，随着原始训练数据集从 10，000 个应用程序增加到 50，000 个应用程序，线性时间从 3s 到 27s 不等，而 MamaDroid 需要从 26s 到 1,207s 不等的非线性时间。在检测阶段，DroidEvolver平均需要 1.37s 才能处理未知应用程序，而 MamaDroid 在这种情况下平均需要 39.15s。</p>
<p>​ 我们还分析随着时间的推移在恶意软件检测过程中识别的老化模型和漂移应用程序。DroidEvolver 将 11.23% 的新应用识别为漂移，而每个检测模型均显示老化迹象，平均对大约 30.13% 的漂移应用进行分类。这些百分比在以后的应用开发后进行评估时保持稳定。此外，超过 50.00% 的检测模型被确定为老化，用于对 49.08% 的漂移应用进行分类。这些漂移应用程序是错误分类的主要来源，而老化模型的更新使DroidEvolver在恶意软件检测中延缓老化。</p>
<p><strong>本文的贡献主要如下：</strong></p>
<ul>
<li>我们提出了一种新的自我进化和高效的Android恶意软件检测系统 DroidEvolver。DroidEvolver 不仅在与训练应用程序同时开发的应用程序上，而且在使用新技术和新 API 训练应用程序后开发的新应用程序上，在恶意软件检测方面都是准确的。</li>
<li>DroidEvolver是有效的，因为DrodEvolver利用在线学习算法更新其老化模型从个别漂移应用程序在恶意软件检测，而不是定期从一批累积应用程序集合的再训练。与最先进的恶意软件检测系统 MAMADROID 相比，DroidEvolver在我们的实验中实现了更高的精度和更高的效率。</li>
</ul>
<p><strong>其余文件的架构如下</strong></p>
<ul>
<li>第二节详细说明了 DroidEvolver 的系统设计</li>
<li>第三节介绍了实验中使用的实验设置和参数调谐</li>
<li>第四节从不同方面评价 DroidEvolver，分析实验结果并讨论其局限性</li>
<li>第五节总结了相关工作</li>
<li>第六节总结了论文</li>
</ul>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu1-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图1：DroidEvolver架构"></p>
<h2 id="droidevolver设计">2、DroidEvolver设计</h2>
<p>​ DroidEvolver 的结构1如图1所示。 DroidEvolver 由两个阶段组成，包括<em>初始化阶段</em>和<em>检测阶段</em>。</p>
<ul>
<li>在<strong>初始化阶段</strong>，DroidEvolver 将一组已知应用程序作为输入，这些应用程序与真实标签（即"恶意"和"良性"）相关联，并输出一组特征和一组检测模型，这些特征和模型被传输到检测阶段</li>
<li>在<strong>检测阶段</strong>，DroidEvolver 将每个真实标签未知的应用程序作为输入，并为未知应用输出预测标签</li>
</ul>
<p>​ DroidEvolver 的初始化阶段由四个模块组成，包括<em>预处理器</em>、<em>特征提取</em>、<em>矢量生成</em>和<em>模型池结构</em>。</p>
<p>​ 对于输入中的每一个已知应用程序，预处理器应用 <strong>apktool</strong> 来分解其 apk 文件并获取其拆解的 <strong>dex 字形码</strong>，其中包括本应用程序中使用的 API 调用。</p>
<p>​ 然后，特征提取模块用于提取所有 Android API，并将每个应用程序的 Android API 二进制存在记录为应用程序的检测特征。<em>初始特征集</em>（即总命令集）是通过结合输入中所有应用程序的检测特征构建的。特征空间由 1 比 1 映射构建，从初始特征集的所有特征到特征空间的尺寸。</p>
<p>​ 在矢量生成模块中，DroidEvolver 通过将所有检测特征的应用程序映射到特征空间，从所有检测模型的每个应用程序生成一个特征向量，<strong>其中初始特征集中的每个被检测到的特征被映射到组件1</strong>，而其他组件设置为0。</p>
<p>​ 通过输入中所有应用产生的特征向量，模型池构建模块构建了一个<em>初始模型池</em>，<strong>该模型池由一组检测模型组成</strong>。每个检测模型都使用不同的在线学习算法进行初始化，该算法根据其特征向量和真实标签处理所有输入应用程序。</p>
<p>​ 在初始化阶段结束时， DroidEvolver 将初始特征集和初始模型池传输到检测阶段。<strong>模型池中的每个检测模型都与<em>一个特征集指示器</em>相关联</strong>，该指示指示器模型可以处理的特征数量。<strong>所有特征集指标均初始化为初始特征集的大小，并可能在检测阶段增加到更大的值</strong>。</p>
<p>​ <strong>在检测阶段，DroidEvolver 将每个未知应用程序分类为恶意或良性应用，并对特征集和检测模型执行必要的更新</strong>。检测阶段的前三个模块与初始阶段的模块相似，但 (i) 特征集被动态更新以包含<strong>新特征</strong>，(ii) 其序号小于检测模型的特征集（<strong>上一代检测模型所使用的特征集</strong>）中的所有特征的 1 比 1 映射为每个检测模型构建一个特征向量，(iii) DroidEvolver 将应用程序的检测特征映射到检测模型（<strong>这一代所要使用的特征集</strong>）的特征空间，从每个检测模型的每个应用程序生成一个特征向量。</p>
<p>​ 在特征提取模块中， DroidEvolver 根据现有的Android API家族提取Android API，包括 Android、java、javax、junit、apach、json、dom和xml。虽然 API 包的数量从 API 级别 1 的 96 个（2008 年 10 月发布的 Android 版本 1.0）大幅增加到 API 级别 27 的 196 个（2017 年 11 月发布的 Android 版本 8.1），但 <strong>Android API 家族的名称随着时间的推移保持不变</strong>。在其检测阶段，只要新 API 调用的 API 系列保持不变， DroidEvolver 不会错过由 Android 框架演变引起的任何新的 Android API 调用。</p>
<p>​ 检测阶段的最后一个模块是<strong>分类和演化</strong>。在此模块中，DroidEvolver 为输入中给出的每个未知应用程序生成分类结果（恶意或良性）。如果模型池中的某些检测模型在检测未知应用程序时老化，DroidEvolver 会<strong>根据包括未知应用程序中使用的所有新的 Android API 调用</strong>，并将每个老化模型的特征集指示器<strong>更新</strong>为新的特征集的大小，从而逐步更新其特征集（不更改任何现有特征的序号）。此外，<strong>DroidEvolver 根据分类结果和更新的特征向量，通过从未知应用程序中学习来更新每个老化模型</strong>。</p>
<p>​ 本节的其余部分阐明了模型池在初始阶段的构建方式，以及如何在检测阶段实现分类和演变。</p>
<h3 id="模型池建设">2.1、模型池建设</h3>
<p>​ 由于在初始化阶段有一组已知应用程序及其相关的真实标签，DroidEvolver 构建了一个模型池，其中<strong>具有一组在线学习算法</strong>，而不是用于恶意软件检测的任何单一检测模型。单个检测模型能力有限，可能不一定提供提供准确的检测结。模型池可以帮助检测和降低任何单一检测模型的偏差，并在检测阶段生成更可靠的检测结果。</p>
<p>​ 模型池中的每个检测模型都使用不同的在线学习算法构建，该算法一次处理一个应用程序。在线学习的复杂度与输入中的应用程序数量是成正比的，这与需要同时处理一组应用程序的批次学习不同。下面给出了DroidEvolver 中在线学习算法的常见过程：</p>
<p>​ 让 DroidEvolver 的输入成为 <em>N</em> 已知应用程序的总命令集。让 <span class="math inline">\(x_t\)</span> 是输入中 <em>t-th</em> 应用程序的<span class="math inline">\(d\)</span> 维真实值特征向量，其中 <span class="math inline">\(d\)</span> 是源自特征提取模块中的输入的初始特征集的大小。让 <span class="math inline">\(y_t\)</span> 是输入中 第 <span class="math inline">\(t\)</span> 应用程序的真实标签，其中 <span class="math inline">\(y_t=+1\)</span> 表示 ”恶意“ 和 <span class="math inline">\(y_t = +1\)</span> 表示 ”良性“。每个在线学习算法的输入是 <span class="math inline">\((x_t， y_t), t = 1,..., N\)</span> ，每个在线学习算法都使用一个检测模型，该模型由<em>d</em>维权重向量表示<span class="math inline">\(w_t\)</span>，处理 <span class="math inline">\((x_t， y_t)，1 ≤ t ≤ N\)</span> 权重向量由初始特征集中所有特征的权重组成。</p>
<p>​ 在每一步<em>t</em>，每个在线学习算法过程 <span class="math inline">\(x_t\)</span> 并生成预测标签 <span class="math inline">\(\hat{y_t} = sgn(w_t,x_t)\)</span>， 其中<span class="math inline">\(sgn\)</span>是一个函数， 将任何非负值映射到 +1， 并将任何负值映射到 -1。损失值 <span class="math inline">\(l_t(y_t，\hat{y_t})\)</span> 在步骤 <span class="math inline">\(t\)</span> 然后从真实标签计算 <span class="math inline">\(y_t\)</span> 和预测标签 <span class="math inline">\(\hat{y_t}\)</span> 每个在线学习算法都对如何计算损失值实施不同的策略<span class="math inline">\(l_t\)</span> 并将其权重向量 <span class="math inline">\(w_t\)</span> 更新为 <span class="math inline">\(w_{t+1}\)</span>。</p>
<p>​ 在 DroidEvolver 中，每个探测模型都定义了超平面 <span class="math inline">\(\{x∈\mathbb{R}^d|w_t ⋅ x = 0\}\)</span>，其中 <span class="math inline">\(w_t\)</span> 是部分在线学习算法生成的检测模型的权重向量。具有权重向量的检测模型 <span class="math inline">\(w_t\)</span> 和 对应用程序进行分类的特征向量与模型超平面的距离 <span class="math inline">\(x_t\)</span>相乘：如果距离<span class="math inline">\(w_t•x_t\)</span>非负数，预测标签为”恶意“：否则，预测标签是”良性的“。绝对值 <span class="math inline">\(w_t•x_t\)</span> 被称为模型的<strong>预测分数<span class="math inline">\(xt\)</span></strong></p>
<p>​ DroidEvolver 构建了由五个线性在线学习算法组成的模型池，包括<strong>Passive Aggressive（PA） 、在线梯度下降（OGD）、权重向量的自适应规范化（AROW）、规范化双平均（RDA） 和自适应向前向后拆分（Ada-FOBOS）</strong>。这些算法涵盖了主要的在线学习算法类别，包括一阶在线学习（包括PA和OGD），二阶在线学习（包括AROW），以及具有规范化的在线学习（包括RDA和Ada-FOBOS）。</p>
<p>​ 一阶在线学习算法旨在仅使用一阶梯度信息优化目标特征。一阶算法的优点是其计算复杂性与输入大小是线性的。与仅利用梯度一阶衍生信息进行在线优化任务的一阶在线学习算法不同，二阶在线学习算法利用一阶和二阶信息来加速优化融合。但是，二阶在线学习算法在处理高维数据时往往具有很高的计算复杂性。这一挑战可以通过具有规范化的在线学习算法来应对，该算法旨在利用真实世界高维数据的稀缺性属性。此外，<strong>每个类别中选定的算法在更新策略、学习速度、优化方法和损失特征方面都有所不同</strong>，这使得当 DroidEvolver 应用于恶意软件检测时，各种检测模型在模型池中的老化方式会有所不同。下面解释了选定的在线学习算法的更新程序。</p>
<h4 id="passive-aggressivepa">Passive Aggressive（PA）</h4>
<p>​ PA 以多个步骤逐步构建其检测模型。在每一步 <span class="math inline">\(t\)</span> 中，PA 都会接受样本 <span class="math inline">\(x_t\)</span> 使用当前模型<span class="math inline">\(w_t\)</span>，预测其标签 <span class="math inline">\(\hat{y}_t\)</span> ；然后，它收到 <span class="math inline">\(x_t\)</span> 真正的标签 <span class="math inline">\(y_t\)</span> 并计算铰链损失<span class="math inline">\(l_t = max\{0, 1 - y_t(w_t * x_t)\}\)</span>。最后，PA 将学习率设定为 <span class="math inline">\(l_t = max\{0, 1 - y_t(w_t * x_t)\}\)</span> 并更新 <span class="math inline">\(w_{t+1} = wt + τ_ty_tx_t\)</span>。</p>
<p>​ 在每一步中，如果铰链损失为 0（即，<span class="math inline">\(w_{t+1} = w_t, 如果l_t= 0\)</span>），模型更新就是消极的。否则，PA 更新 <span class="math inline">\(w_{t+1}\)</span> 就是积极。PA 确保更新 <span class="math inline">\(w_{t+1}\)</span> 应保持接近 <span class="math inline">\(w_t\)</span> 并且每个传入的样本都应通过更新后的模型正确分类。</p>
<h4 id="在线梯度下降-ogd">在线梯度下降 （OGD）</h4>
<p>​ OGD 具有与 PA 类似的更新策略，但 OGD 采用预先定义的学习率计划，而 PA 则在每一步中选择最佳学习率。在每一步 <span class="math inline">\(t\)</span> 中，OGD 都会收到样本 <span class="math inline">\(x_t\)</span> 使用当前模型<span class="math inline">\(w_t\)</span>，预测其标签 <span class="math inline">\(\hat{y}_t\)</span> ；然后，它收到 <span class="math inline">\(x_t\)</span> 真正的标签 <span class="math inline">\(y_t\)</span> 并计算铰链损失<span class="math inline">\(l_t = max\{0, 1 - y_t(w_t * x_t)\}\)</span>。之后，OGD 更新 <span class="math inline">\(w_{t+1}= ∏_S(w_t-η_t∇l_t(w_t))\)</span>， 其中 <span class="math inline">\(η_t\)</span> 是预先定义的学习率， <span class="math inline">\(S\)</span> 是一个凸集且初始化为 <span class="math inline">\(t = 0\)</span>， 且 <span class="math inline">\(∏_S\)</span> 是将更新的模型限制在可行域中的投影函数。具体地说，如果<span class="math inline">\(w_t-η_t∇l_t(w_t) \notin S\)</span>，<span class="math inline">\(∏_S\)</span>将 <span class="math inline">\(w_t-η_t∇l_t(w_t)\)</span> 投影到 <span class="math inline">\(S\)</span> 中距离 <span class="math inline">\(w_t-η_t∇l_t(w_t)\)</span> 最近的向量，这个被投影的向量即为 <span class="math inline">\(w_{t+1}\)</span></p>
<h4 id="权重向量的自适应规范化arow">权重向量的自适应规范化（AROW）</h4>
<p>​ AROW 将不同特征的出现频率考虑到模型更新中。<strong>在 AROW 中，常见的特征会收到更多的更新，并且与较少的特征相比，常见的特征估计更准确。</strong></p>
<p>​ AROW 在特征权重上保持高斯分布（均值为 <span class="math inline">\(μ\)</span> 和方差为 <span class="math inline">\(Σ\)</span> ，即 $ w N(μ, Σ)$ ）。ROW初始化 <span class="math inline">\(μ_0 = 0\)</span> 和 <span class="math inline">\(Σ_0= I, 即单位矩阵\)</span>。给定 <span class="math inline">\(x_t\)</span> 在每一步 <span class="math inline">\(t\)</span> 中，AROW 计算边距 <span class="math inline">\(mt = μ_{t-1} • x_t\)</span>和 置信度 <span class="math inline">\(v_t = x_t ^⊤ ∑_{t-1}x_t\)</span>。</p>
<p>​ 然后，它收到 <span class="math inline">\(x_t\)</span> 真正的标签 <span class="math inline">\(y_t\)</span> ，AROW 损失 <span class="math inline">\(l_t = 1\ if\ sgn(m_t) ≠ y_t\)</span>。 $$ 
\mu _t = {\mu _{t - 1}} + \frac{{\max (0,1 - {y_t}{x_t}^{^ \top }{\mu _{t - 1}})}}{{{x_t}^{^ \top }{\Sigma _{t - 1}}{x_t} + r}}{\Sigma _{t - 1}}{y_{{t^X}t}}
$$  ​ <span class="math inline">\(r\)</span> 是由参数调谐设置的输入参数</p>
<p>​ 如果 <span class="math inline">\(μt≠μ_{t+1}\)</span>， AROW 更新方差 <span class="math inline">\(\Sigma_t\)</span> ： $$ 
\Sigma _t = {\Sigma _{t - 1}} - \frac{{{\Sigma _{t - 1}}{x_t}{x_t}^{^ \top }{\Sigma _{t - 1}}}}{{{x_t}^{^ \top }{\Sigma _{t - 1}}{x_t} + r}}
$$  ​ 之后，AROW 输出更新的平均值 <span class="math inline">\(μ_t\)</span> 和 方差 <span class="math inline">\(∑_t\)</span>，然后用于计算更新的权重向量。</p>
<h4 id="正规化双平均值rda">正规化双平均值（RDA）</h4>
<p>​ RDA 通过解决每个样本的最小化问题来调整其参数。在每一步 <span class="math inline">\(t\)</span> 中，RDA 计算子梯度 <span class="math inline">\(g_t∈∂f_t(w_t)\)</span>，其中 <span class="math inline">\(f_t\)</span> 是步骤 <span class="math inline">\(t\)</span> 的代价函数。子梯度 <span class="math inline">\(g_t\)</span> 用于计算平均子梯度。然后，RDA 会更新平均子梯度：<span class="math inline">\(\bar{g_t}=\frac{t-1}{t} + \frac{\bar{g_t}}{t}\)</span> 。 Rda 通过解决最小化问题更新当前的权重向量： $$ 
\begin{equation*}{w_{t + 1}} = \arg \mathop {\min }\limits_w \left\{ {{{\bar g}_t}^{^ \top }w + \Psi (w) + \frac{{{\beta _t}}}{t}h(w)} \right\}\end{equation*}
$$  ​ 其中 <span class="math inline">\(β_t\)</span> 是一个非负序列，$Ψ(w) $ 是原始的稀疏诱导规范 （即，<span class="math inline">\(Ψ(w) = λ‖w‖_1\)</span>）<span class="math inline">\(h(w)\)</span> 是辅助强凸函数（即<span class="math inline">\(h(w)= \frac{1}{2}∥w∥^2\)</span>），<span class="math inline">\(\bar{g_t}\)</span> 是所有以前迭代的平均子梯度和 （即$ {g} =  * _{t}^{τ=1}∇l_τ(w_τ))$）</p>
<h4 id="自适应向前向后拆分ada-fobos">自适应向前向后拆分（Ada-FOBOS）</h4>
<p>​ RDA 的一个主要问题是，基础数据分布的几何信息可能无法被辅助强凸函数<span class="math inline">\(h(w)\)</span>充分利用。为了应对这一挑战，Ada-FOBOS 提出了一个数据驱动的<strong>自适应规范化</strong><span class="math inline">\(h(w)\)</span>： $$ 
\begin{equation*}{h_t}(w) = \frac{1}{2}{w^{^ \top }}{H_t}w\end{equation*}
$$  其中 <span class="math inline">\(H_t\)</span> 是对角矩阵。</p>
<p>​ 更新过程描述如下：在每一步 <span class="math inline">\(t\)</span>，Ada-FOBOS 接收 <span class="math inline">\(x_t\)</span> 并预测其标签 <span class="math inline">\(\hat{y}_t\)</span>。 然后，它遭受损失 <span class="math inline">\(l_t\)</span> 并计算相对于 <span class="math inline">\(w_t\)</span> 的梯度 <span class="math inline">\(g_t\)</span>。 之后，它更新 <span class="math inline">\(h_t(w)\)</span> 的对角矩阵 <span class="math inline">\(H_t\)</span>： $$ 
\begin{equation*}{H_t} = \delta + diag\left(\sum\limits_{i = 1}^t {{g_i}} {g_i}^{^ \top }\right)\end{equation*}
$$  其中δ是确保自适应加权矩阵的正确定属性的参数。最后，Ada-FOBOS 更新权重向量 <span class="math inline">\(w_t+1 = w_t − \frac{τg_t}{H_t}\)</span>，其中 <span class="math inline">\(τ\)</span> 是学习率。</p>
<p>​ 在处理了输入中所有的应用程序后，DroidEvolver 输出了五个检测模型作为模型池，并将每个检测模型与一个特征集指示器关联在一起，该指示器初始化为初始特征集的大小。然后，DroidEvolver 将模型池传输到检测阶段进行分类和进化。</p>
<h3 id="分类和演变">2.2、分类和演变</h3>
<p>​ 在检测阶段，分类和演化模块对每个未知应用进行分类，并对其特征集和模型池进行必要的更新。该模块由三个步骤组成，包括<strong>漂移应用识别</strong>、<strong>分类和伪标签生成</strong>以及<strong>老化模型聚光化</strong>。</p>
<h4 id="漂移应用程序标识与何时演变">漂移应用程序标识与何时演变</h4>
<p>​ 使用旧应用程序进行训练的恶意软件检测模型在检测开发比训练数据较晚的新应用程序时通常会产生不令人满意的结果。这种现象被称为<strong>概念漂移</strong>。为了使恶意软件检测适应概念漂移，DroidEvolver 识别了与以前处理过的旧应用程序不同的漂移应用程序。对于每个漂移应用程序，DroidEvolver 可识别显示老化迹象的老化模型，以对漂移应用进行分类。漂移应用的出现表明有必要更新DrodEvolver的相应老化模型，以保持其在恶意软件检测中的有效性。</p>
<p>​ DroidEvolver 使用<strong>聚光化指示器</strong>（简称 JI）来确定未知应用程序在检测模型处理时是否漂移。简言之，JI 表示新应用程序与检测模型测量的一批应用程序之间的相似性。为了高效计算 JI 的新应用程序，DroidEvolver 使用<strong>App数组</strong> <span class="math inline">\(B = (b_1,...,b_k), size = K\)</span>存储已处理的应用程序子集的特征向量，其中 <span class="math inline">\(K (≤ N)\)</span>是 DroidEvolver 中的参数，<span class="math inline">\(b_t, (1≤ t ≤ K)\)</span> 是以前处理过的某些应用程序的特征向量。</p>
<p>​ 在检测阶段的开始，App数组中的 <span class="math inline">\(K\)</span> 中的App 是从初始阶段给出的输入中随机选择的。为了保持现有应用数组的更新，每当将新应用程序作为检测阶段的输入时，DroidEvolver 会随机选择 App数组中的一个特征向量，替换为 JI 计算新应用程序的特征向量。</p>
<p>​ 特别是，假设 DroidEvolver 已经完成了对第 <span class="math inline">\((i-1)\)</span> 个未知应用程序的检测，并收到了新的App <span class="math inline">\(A_i\)</span>。</p>
<p>​ <span class="math inline">\(x_i\)</span> ： <span class="math inline">\(A_i\)</span> 的特征向量</p>
<p>​ <span class="math inline">\(M_j\)</span>：是第j个检测模型（使用当前模型池）</p>
<p>​ <span class="math inline">\(B\)</span>：被<span class="math inline">\(A_j\)</span> 更新过的 App数组</p>
<p>​ <span class="math inline">\(σ\)</span>：指示函数，<span class="math inline">\(σ(true) = 1, σ(false) = 0\)</span></p>
<p>​ 对于模型 <span class="math inline">\(M_j\)</span> 检测 App <span class="math inline">\(A_i\)</span> 的聚光化指示器 JI 为： $$ 
\begin{equation*} {\xi _{ij}} = \begin{cases} {\frac{{\sum\limits_{{b_t} \in B} \sigma ({w_j}\cdot{x_i}. \geq {w_j}\cdot{b_t})}}{{\sum\limits_{{b_t} \in B} \sigma ({w_j}{b_t} \geq 0)}}}&{{\text{if}}\;{w_j}\cdot{x_i} \geq 0} \\ {\frac{{\sum\limits_{{b_t} \in B} \sigma ({w_j}.{x_i} < {w_j} \cdot {b_t})}}{{\sum\limits_{{b_t} \in B} \sigma ({w_j} \cdot {b_t} < 0)}}}&{{\text{else}}} \end{cases}\tag{1}\end{equation*}
$$  ​ 在 <span class="math inline">\(ξij\)</span> 的定义中，<span class="math inline">\(M_j\)</span> 对 <span class="math inline">\(A_i\)</span> 的<strong>预测分数</strong>与 <span class="math inline">\(M_j\)</span> 对App数组中由 <span class="math inline">\(M_j\)</span> 分类到 <span class="math inline">\(A_i\)</span> 的预测标签的应用程序的预测分数进行比较。</p>
<p>​ 如果 <span class="math inline">\(M_j\)</span> 对 <span class="math inline">\(A_i\)</span> 的预测标签是恶意的（分别是良性的），<span class="math inline">\(M_j\)</span> 的 App 数组来说中的App， <span class="math inline">\(M_j\)</span> 对 <span class="math inline">\(A_i\)</span> 的预测分数在<span class="math inline">\((100•ξ_{ij}\%, 100•(1− ξ_{ij})\%)\)</span>之间，将被 <span class="math inline">\(M_j\)</span> 分类为“恶意”。</p>
<p>​ 如果 <span class="math inline">\(A_i\)</span> 的特征向量 <span class="math inline">\(x_i\)</span> 与应用程序缓冲区中包含的其他特征向量（即来自处理应用程序的异常值）相比，离 <span class="math inline">\(M_j\)</span> 的超平面太近或太远，则 <span class="math inline">\(A_i\)</span> 被识别为检测模型 <span class="math inline">\(M_j\)</span> 的漂移应用程序。 DroidEvolver 使用两个阈值 <span class="math inline">\(τ_0 ,τ_1(0 ≤ τ_0 ≤ τ_1 ≤ 1)\)</span>，根据 JI 值识别漂移应用程序。 如果<span class="math inline">\(τ_0 ≤ ξ_{ij} ≤ τ1\)</span>，则认为 <span class="math inline">\(ξ_{ij}\)</span> 有效； <strong>否则，<span class="math inline">\(ξ_{ij}\)</span> 无效，则将 <span class="math inline">\(M_j\)</span> 标记为检测 <span class="math inline">\(A_i\)</span> 的老化模型</strong>，其中 <span class="math inline">\(ξ_{ij} ≤ τ_0\)</span> 在初始化阶段被选择并在检测阶段被强制执行。 <strong>如果模型池中的任何检测模型是用于检测它的老化模型，则未知应用程序被识别为漂移应用程序</strong>。 每当识别出漂移应用程序时，DroidEvolver 都会对其特征集和模型池中的老化模型进行必要的更新。</p>
<h4 id="分类---伪标签生成-与-什么一起进化">分类 - 伪标签生成 与 什么一起进化</h4>

​	在检测阶段，DroidEvolver 通过加权投票生成每个未知应用程序的分类结果。如果输入应用程序 $A_j$ 不是漂移应用程序，加权投票由模型池中的所有检测模型使用执行   ${\textstyle \sum_{j=1}^{M}} {{w_j} \cdot {x_i}}$ 其中 $M$ 是模型池的大小，$w_j$ 是模型的权重向量 $M_j$ 在模型池中， $x_i$是$A_i$的特征向量，如果模型投票是非阴性的，被归类为"恶意"，否则，其分类结果为"良性"。

<p>​ 如果<strong>输入应用程序被确定为漂移应用程序</strong>，则模型池中的检测模型执行加权投票，时不包括所有检测该应用已经老化的模型。然后，漂移应用程序的分类结果用作其伪标签，用于更新特征集和所有老化型号。在另一种情况下，所有模型都在老化或没有模型正在老化，DroidEvolver 在模型池中执行所有模型之间的加权投票，并跳过更新过程。</p>
<h4 id="老化模型聚化---如何进化">老化模型聚化 - 如何进化</h4>
<p>​ 模型池中漂移应用和老化模型的适当子集的识别表明，由于以下原因，应根据漂移应用对老化模型进行聚合，以便随着时间的推移进行可靠的恶意软件检测。首先，漂移应用程序与其他处理应用程序之间的差异可能由<strong>漂移应用程序中包含的新特征或新模式引起</strong>。因此，适应这些新特征非常重要。此外，<strong>老化模型的检测能力受到”老化“特征集和模型结构的限制</strong>，需要更新这些特征，以便将来进行准确的分类。</p>
<p>​ 在这种情况下，DroidEvolver <strong>首先更新其当前特征集</strong>，包括从漂移应用程序中提取的所有新特征。然后，<strong>DroidEvolver 通过学习漂移应用和相应的伪标签，单独更新每个老化模型的特征集指示器和模型结构</strong>。模型结构包括权重向量的维度（根据当前特征设置指标）和权重向量的值（根据处理应用程序中包含的特征）。</p>
<p>​ 让 <span class="math inline">\(y_i\)</span> 表示漂移应用程序的伪标签，<span class="math inline">\(W_j\)</span> 表示老化模型的权重向量，DroidEvolver 更新每个对于 <span class="math inline">\(A_j\)</span> 老化模型 <span class="math inline">\(M_j\)</span> 分为四个步骤：首先，DroidEvolver 使用 <span class="math inline">\(M_j\)</span> 计算 <span class="math inline">\(A_j\)</span> 的预测标签 $_t $ 。然后，它揭示了伪标签 <span class="math inline">\(y_i\)</span> 自 <span class="math inline">\(M_j\)</span> 并计算损失值。为 <span class="math inline">\(Mj\)</span> 根据损失函数 <span class="math inline">\(l_j\)</span> 之 <span class="math inline">\(M_j\)</span> 在线学习算法。</p>
<p>​ 第三，更新特征集指标 <span class="math inline">\(M_j\)</span> 是更新的特征集的大小，并更新后的特征集和更新的特征集指示器更新 <span class="math inline">\(A_j\)</span> 的特征向量根据。最后，它依赖于在线学习算法 <span class="math inline">\(M_j\)</span> 决定更新的时间和方式 <span class="math inline">\(M_j\)</span> 根据更新策略。</p>
<p>​ <strong>特征集和老化模型的必要更新使 DroidEvolver 能够适应 Android 应用程序和 Android 框架的变化</strong>。与现有的基于在线学习的方法不同，DroidEvolver 依靠模型池而不是单个检测模型来生成其检测结果。此外，DroidEvolver 不需要更新老化模型的漂移应用程序的真实标签。</p>
<h2 id="实验设置和参数调谐">3、实验设置和参数调谐</h2>
<p>在一系列实验中，对DroidEvolver 的表现进行了经验评估。本节详细介绍了实验设置和参数调整。</p>
<h3 id="数据收集">3.1、数据收集</h3>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t1-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="表1 - 近些年的数据集分布"></p>
<p>​ 我们在 2017 年 7 月从一个开放的 Android 应用程序收集项目收集了一组应用程序。我们数据集中应用的标签是由我们在 2017 年 8 月从 VirusTotal获得的报告确定的，该报告是一个具有 63 个扫描仪的服务。</p>
<ul>
<li>如果应用程序<strong>没有收到来自所有扫描仪的警报</strong>，则会标记为良性。</li>
<li>另一方面，如果应用程序<strong>收到来自 63 台扫描仪的至少 15 个警报（即大约 24% 的扫描仪发出警报）</strong>，则该应用程序会被标记为恶意。</li>
</ul>
<p>​ 我们标记应用程序的方式与之前关于恶意软件检测的研究一致。例如，Arp 等人将应用程序标记为恶意，如果它收到来自至少 20% 的扫描仪的警报。生成的良性数据集由 33,294 个应用程序组成，恶意数据集包含 34,722 个应用程序。每个应用程序的时间由应用程序的 apk 文件打包的时间决定，该文件包含在 apk 文件的 dex 文件中。收集的数据集中的应用程序日期涵盖 2011 年至 2016 年。如表一所示，每个数据集都包含几乎平衡的良性应用程序（42.1%-50.5%）和恶意应用程序。</p>
<h3 id="指标和测量">3.2、指标和测量</h3>
<p>The performance of DroidEvolver is assessed using standard F-measure, i.e.: $$ 
\begin{equation*}{\text{F}} - {\text{measure}} = 2 \cdot \frac{{{\text{Precision}} \cdot \operatorname{Re} {\text{call}}}}{{{\text{Precision}} + \operatorname{Re} {\text{call}}}}\end{equation*}
$$  其中 <span class="math inline">\(Precision = TP/(TP+FP),\ Recall= TP/(TP+FN)\)</span></p>
<p>TP 表示正确检测的恶意应用程序数量</p>
<p>FP 表示被错误地检测为恶意的良性应用程序数量</p>
<p>FN 表示被错误地检测为良性的恶意应用程序数量</p>
<p>在下面描述的两种情况下检测 DroidEvolver 的表现</p>
<p><strong>同一时间段内的表现</strong>。为了避免过度拟合，选择DroidEvolver 的参数，以便DroidEvolver 在训练集初始化后在验证集上实现最佳表现：然后，DroidEvolver 的表现在测试集上进行评估，其中训练集、验证集和测试集是在同一时间段内开发的不同应用程序集，没有重叠。</p>
<p>​ 我们的实验有六个时间段，包括 2011 年、2011-2012 年、2011-2013 年、2011-2014 年、2011-2015 年和 2011-2016 年。在每个时间段内，应用程序都会随机洗牌，并分为五个大小相等的子集。我们随机选择三个子集作为训练集，一个子集作为验证集，其余子集作为测试集。</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu2-p16-xu-large.gif"><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu2-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="Fig. 2: - Detection F-measure under Different Thresholds"></a></p>
<h3 id="参数选择">3.3、参数选择</h3>
<p>​ 对于每个时间段，选择参数，以便 DroidEvolver 的表现在通过训练集初始化后，通过验证集进行优化。然后强制执行选定的参数，以检测测试集中的恶意软件（日期为相同或较晚的时间段）。在以下情况下，我们将显示参数调整在实验环境中的执行情况，我们称之为默认设置。在此设置中，2011 数据集用于形成训练集（6,286 个应用程序）和验证集（2,095 个应用程序）。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t2-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="表二 - 同一时期检测的DroidEvolver 和 MAMADROID 表现"></p>
<h4 id="阈值调整">阈值调整</h4>
<p>​ 两个阈值：<span class="math inline">\(τ_0\)</span> 和 <span class="math inline">\(τ_1\)</span>，用于根据检测阶段的 JI 值识别漂移应用和老化模型。</p>
<p>​ 图2 显示了在默认设置中调整阈值对 DroidEvolver 表现的影响。图2说明，当 DroidEvolver 的 F-score 稳定时，<span class="math inline">\(τ_0\)</span> 从 0.1 增加到 0.3 ， <span class="math inline">\(τ_1\)</span> 从 0.6 增加到 0.8。当 $ τ_0 = 0.3, τ_1 = 0.7$，F -score 达到其最大值 96.33%，在验证集上达到最佳表现，DroidEvolver 选择 $ τ_0 = 0.3, τ_1 = 0.7$ 。</p>
<h4 id="app数组大小调整">App数组大小调整</h4>
<p>​ 回想一下，在分类和演化模块中使用了App数组，以便高效计算 JI。<strong>应用缓冲<span class="math inline">\(B\)</span>的<span class="math inline">\(K\)</span>大小会影响漂移应用程序的识别</strong>，从而影响 DrodEvolver 的检测 <span class="math inline">\(F -score\)</span> 以及处理所有未知应用程序所需的时间。</p>
<p>​ 图3 显示了 DroidEvolver 的 <span class="math inline">\(F - score\)</span> 以及不同 App数组大小下分类和演化模块中 2,095 个应用程序的处理时间，其中阈值设置为+0• 0.3和 +1= 0.7。当应用缓冲大小K从 10 增加到 10,000 时，DrodEvolver 的 F - score 从 91.45% 到 96.41% 不等， 表明 <strong>F-score 对 K 的变化不太敏感</strong>。另一方面，随着 <span class="math inline">\(K\)</span> 从10到10,000的变化，所有应用程序的处理时间从 200 显著增加到 4,759。为了平衡 F - score 和效率，<strong>DroidEvolver 在默认设置中选择 K = 500</strong>。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu3-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图 3： - App数组大小调谐"></p>
<h2 id="评价和分析">4、评价和分析</h2>
<p>​ 在本节中，使用表一中总结的数据集，在一系列实验中评估和分析 DroidEvolver 的表现。DroidEvolver 的表现与 MAMADROID 进行比较，MAMADROID 是一种最先进的恶意软件检测系统，能够适应 Android API 随时间的变化。MAMADROID 首先使用Soot 和 FlowDroid 从每个应用程序中提取 API 调用图；然后，它从 API 调用图中提取一组 API 调用序列，并抽象每个 API 调用在包模式下的包或在家族模式下对其家族。从抽象的 API 调用序列中，MAMADROID 通过评估抽象 API 调用之间所有转换的概率来构建马尔科夫链。然后，它根据其 Markov 链从每个应用程序中获取一个特征矢量，其中每个非零特征向量组件是马尔科夫链中的相应概率。MAMADROID 使用批量学习算法构建检测模型并检测未知应用的恶意软件。</p>
<p>​ 为了表现比较，我们使用其源代码实现了 MAMADROID，并在其包模式（始终优于家族模式）中操作它，其中批量学习分类算法是随机森林（有最佳表现）。我们在同一实验环境中评估了 DroidEvolver 和 MAMADROID。</p>
<h3 id="同一时间段内检测">4.1、同一时间段内检测</h3>
<p>​ 表二比较了DroidEvolver 和MAMADROID在F-score、精度和召回方面的表现。在每个实验中，DroidEvolver 和 MAMADROID 都使用相同的训练集进行初始化/训练，并使用相同的测试集进行评估。在所有实验中，DroidEvolver 机始终显著地超过MAMADROID，平均实现15.80%的 F-score，12.97%的精度和17.57%的召回率。通过从漂移应用中学习并适应新变化，DroidEvolver 平均使用 Android API 作为检测特征实现了 96.15% 的 F-score。</p>
<h3 id="随着时间推移检测">4.2、随着时间推移检测</h3>
<p>​ 我们的下一个和主要重点是 DroidEvolver 和MAMADROID的检测表现随着时间的推移，他们的检测模型训练与一组应用程序在一个时间段内开发，然后测试与另一组应用程序在以后的时间段开发。</p>
<p>​ 如图4所示，在所有实验中， DroidEvolver 的对于老化的表现都比MAMADROID获得显著优势。当 DroidEvolver 在测试组上评估比训练集新一到五年时， DroidEvolver 的平均 F-score 分别为92.32%、89.30%、87.17%、87.46%和89.97%。相比之下，在相应情况下，MAMADROID的平均F-score分别为68.01%、56.09%、45.88%、32.85%和8.81%。随着时间的推移， DroidEvolver 的整体 F-score 值比 MAMADROID 的平均值高出 2.11 倍。五年来， DroidEvolver 的 F-score 平均每年下降1.06%，而MAMADROID在相同情况下每年平均下降13.52%。</p>
<p>​ 图4还显示，在运行了两到三年之后， DroidEvolver 的 F-score 变得稳定。在其检测阶段，DroidEvolver 会自动从带有伪标签的漂移应用程序中学习，并更新其特征集和模型池。相比之下，MAMADROID 中的检测模型在训练后不会发生任何变化。与MAMADROID相比， DroidEvolver 的优势更为明显，在默认设置中，训练集相对较旧，体积较小，如图4a所示。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu4-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="Fig. 4: - DroidEvolver 和 MAMADROID 的检测表现：a、b、c、d和e分别显示2011年、2011年、2012年、2011年和2011年以及2011年训练组的初始训练结果"></p>
<h3 id="模型更新的影响">4.3、模型更新的影响</h3>
<p>​ DroidEvolver 通过从没有真实标签的漂移应用程序中学习，在检测阶段执行必要的模型更新。尽管如此，<strong>如果某些应用程序有真实的标签，DroidEvolver 可以在此类应用程序上执行轻量级模型更新</strong>。</p>
<p>​ 在使用 2011 年训练集初始化后，DroidEvolver 和 MAMADROID 通过更新其模型，在恶意软件检测过程中，使用带有真实标签的随机选择漂移应用程序的固定百分比进行进一步测试，<strong>其中漂移应用程序平均占所有测试应用程序的 11.23%</strong>。如图5所示，DroidEvolver 在所有设置中都明显且始终优于MAMADROID。随着时间的推移，DroidEvolver 的整体 F -score 值比 MAMADROID 的平均值高出 1.44 倍。此外，如果使用真实标签的漂移应用程序更新 60% （或以上）， DroidEvolver 将其平均 F -score 值保持在 92% 以上。由于每年约有 11.23% 的测试应用程序被确定为漂移应用，因此，如果每年只有约 6.74% 的测试应用程序更新了真实标签，DroidEvolver 可以保持其检测表现处于高水平。从少量带有真实标签的应用程序中学习有助于 DroidEvolver 以更高的质量更新自身，并实现更好的检测表现。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu6-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图 6： - 默认设置中 DroidEvolver、一般的 DroidEvolver 解决方案和 MAMADROID 的检测表现"></p>
<p>​ 如图5中的白条所示，当带有真实标签的漂移应用百分比从0%增加到100%时，DroidEvolver 的平均 F-score 值略有不同，从90.51%到92.89%不等。此外，当百分比从 40% 增加到 100% 时，F-score 保持稳定。相比之下，MAMADROID 的平均 F-score 从 41.29% 显著增加到 71.25%，因为百分比从 0% 变为 100%（如图5 中的灰条所示）。与 MAMADROID 相比，<strong>DroidEvolver 对带有真实标签的模型更新不太敏感</strong>，表现也好得多。</p>
<ol type="1">
<li><p>原因一：当没有真正的标签时，DroidEvolver 能够从漂移应用程序的伪标签中学习</p></li>
<li><p>原因二：每个漂移应用程序的<strong>伪标签是通过加权投票产生的</strong>，将老化模型排除在模型池中，这有助于减轻任何单一检测模型的偏差，并生成更可靠的伪标签</p>
<p>当某些应用程序的真实标签可用于模型更新时，DroidEvolver 不仅在功效方面，而且在效率方面都优于 MAMADROID。 <strong>DroidEvolver 可以通过带有真实标签的单个测试应用程序执行即时模型更新</strong>，但 MAMADROID 需要反复进行再训练，将所有带有真实标签的可用测试应用程序纳入训练集。</p></li>
</ol>
<p>​ 通过漂移应用程序更新DroidEvolver中的老化模型的重要性，可以通过测试一个<em>天真的解决方案</em>来进一步证明其合理性，该解决方案没有识别漂移应用程序，也没有执行更新：相反，每个应用程序的分类结果由所有检测模型通过加权投票生成。图 6将 DroidEvolver 的表现与默认设置中的天真解决方案进行了比较。它表明，天真的解决方案的F测量明显低于 DroidEvolver 后，运行了几年。天真的解决方案在恶意软件检测加班中效果较差，因为越来越多的检测模型在恶意软件检测过程中老化，因为没有执行任何更新。</p>
<p>​ 虽然天真的解决方案不如 DroidEvolver 有效，但它仍然大大优于 MAMADROID。在同一实验环境中，其平均F测量比MAMADROID高1.88倍。原因是，在天真的解决方案中执行的加权投票有助于缓解单个检测模型的偏差，从而即使在没有模型更新的情况下也产生更可靠的检测结果。</p>
<h3 id="识别漂移应用和老化模型的影响">4.4、识别漂移应用和老化模型的影响</h3>
<p>​ 分析 JI 值的分布，以显示在检测过程中识别漂移应用和老化模型的重要性。我们的分析是在默认设置中执行的，其中 DroidEvolver 使用 2012 年应用进行了微调参数评估。<span class="math inline">\(τ_0 = 0.3\)</span>，<span class="math inline">\(τ_1= 0.7\)</span> 和 <span class="math inline">\(K = 500\)</span>。仅展示一个模型（即PA）分布的 JI 值，因为对其他模型的分析结果类似。所选的检测模型显示出老化迹象，对 2012 年开发的新应用进行了 3.55% 的分类。当使用后期开发的应用程序进行评估时，此百分比保持稳定（没有显示更多老化迹象），这表明 DroidEvolver 执行的更新使检测模型变慢老化。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu8-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图 8： - 2012 年开发的漂移应用中的 TP、FN、TN 和 FP 的分布"></p>
<p>​ 图7 显示用于分配 JI 值的箱线图。这些框从下四分位数延伸到 JI 值的上四分位数，其中手段和中位数分别标有实心三角形和线条。线从箱中延伸，以显示 JI 值的第 5个百分位和第95个百分位。灰色基线标记 <span class="math inline">\(τ_0\)</span> 和 <span class="math inline">\(τ_1\)</span>，每个红色滤点表示漂移应用程序的无效 JI 值。</p>
<p>​ 图7a 和 图7b 分别显示了 JI 分发的真实恶意应用程序和真正的良性应用程序，<strong>大多数正确的预测（即这些数字中的第一列）都与有效的 JI 值相关联，而大多数错误预测与无效的 JI 值相关联</strong>。在大多数情况下，如果应用程序没有漂移，检测模型可以做出正确的预测：否则，检测模型会老化，可能会错误地对漂移应用程序进行分类。因此，DroidEvolver 通过将所有老化模型排除在加权投票之外，为每个漂移应用生成分类结，然后，<strong>它根据每个漂移应用程序及其伪标签使用在线学习算法更新所有老化模型</strong>。在所有检测模型在分类漂移应用程序时老化的极端情况下，加权投票由所有模型执行，并且在任何模型上不执行任何更新。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu7-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图 7： - 一个检测模型的 JI 值分布"></p>
<p>​ 然后，我们分析已识别的漂移应用程序，以证明漂移应用的影响。该实验在默认设置中执行，其中DroidEvolver分别从2012年、2013年、2014年、2015年和2016年的测试应用程序中识别出1459、1308、1242、1267和1183个漂移应用程序。由于所有漂移应用程序和相应的伪标签都用于更新已识别的老化模型，因此伪标签的正确性对于DroidEvolver的检测表现非常重要，<strong>带有错误伪标签的漂移应用程序可能会错误地更新老化型号</strong>。图8 显示了 2012 年漂移应用程序中的 TP、FN、TN 和 FP 的分布情况。对于所有已识别的漂移应用程序，DroidEvolver 正确地将其中 98.22% 分类为良性或恶意。其余 1.78% 的漂移应用程序具有不正确的伪标签可能会误导DroidEvolver生成不正确的分类结果，并导致恶意软件检测加班的 F 措施的下降。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu10-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图10： - 新特征的分布"></p>
<h3 id="特征演变">4.5、特征演变</h3>
<p>​ <strong>DroidEvolver 的一个主要优点是其特征集没有固定。</strong>它通过吸收在检测过程中从漂移应用程序中提取的新特征而生长。这一优势有助于 DroidEvolver 适应应用演变和Android框架演变带来的新特征。</p>
<p>​ 图9 显示了在默认设置中的特征演变，其中 DroidEvolver 在 2011 年训练集中启动，并在 2012 年至 2016 年开发的应用程序中进行了测试。特别是，图9a 显示，在六年内，提取特征的实际数量从 14,327个增加到 52,001个。模型池中每个检测模型的特征设置指标也观察到类似的增长模式：例如，图 9b 展示了一个检测模型（即PA）的特征设置指标的增长。类似的增长模式表明<strong>（i） DroidEvolver 可以更新其特征集，以包括从漂移应用程序中发现的新特征，（ii）DroidEvolver 的检测模型被更新，以适应恶意软件检测的新特征随着时间的推移</strong>。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu9-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图 9： - 特征演变"></p>
<p>​ 每年添加到特征集的新特征可以被认为是来自两个来源，包括<strong>应用程序演变和 Android 框架演变</strong>。应用程序演变意味着新特征是训练集中未用于任何应用程序或以前处理过的任何漂移应用程序的现有 API。Android 框架的演变意味着新特征是添加到 Android 规格中的新 API。</p>
<p>​ 图10显示，<strong>大多数新特征来自应用程序演变</strong>，而Android框架演变的贡献不容忽视。请注意，新特征的分布可能会在不同的实验设置中更改。尽管如此，应设计一个缓慢老化的恶意软件处理系统，以适应新特征，并随着时间的推移在恶意软件检测中很好地利用它们。</p>
<p><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu11-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="图 11： - TPs、FN、TN 和 FP 的特征 权重分布"></p>
<h3 id="假阳性和假阴性">4.6、假阳性和假阴性</h3>
<p>​ 为了解释为什么误分类假阳性和假阴性，DroidEvolver 为检测到的应用程序的每个特征输出了权重值，特征的权重值表示该特征对分类结果的贡献程度。特别是，应用程序的特征 权重被计算为（<span class="math inline">\(∑_{j∈S} w_j * x\)</span>）， 其中 <span class="math inline">\(S\)</span> 集在模型池中参与加权投票，<span class="math inline">\(w_j\)</span> 是应用进行加权投票时 <span class="math inline">\(S\)</span> 中每个模型的权重向量，<span class="math inline">\(x\)</span> 是该特征的一热向量。请注意，应用程序所有特征的权重之和正是加权投票的结果，该投票用于得出应用程序的分类结果。对于恶意（分别为良性）应用，非负（分别为负）权重显示相应特征对其检测有积极贡献，而权重的绝对值表示贡献有多大。</p>
<p>​ 然后，我们介绍了对假阳性和假阴性进行详细分析，其中 DroidEvolver 对 2012 年的 11,566 份申请进行了评估（包括 5,789 份良性申请和 5,777 份恶意应用）。在这种情况下，DroidEvolver 实现 F-score 95.69%，精度95.91%，真阳性率 93.39%，假阳性率1.70%。</p>
<p>​ <strong>特征权重分布。</strong>我们首先分析真正 （TPs）、假负数 （FN）、真负子 （TN） 和假阳性 （FP） 的特征 权重分布。图 11显示 16 个随机选择应用程序（包括 4 个 TP、4 个 FN、4 个 TN 和 4 个 FP）的框和胡须图，其中每个框从下四分位数延伸至某些应用特征权重的上四分位数，胡须从框中延伸以显示特征权重的第 5<em>个</em>百分位和<em>第 95</em>个百分位， 特征值的平均值（中位数，分别）在框内标有实心三角形（线），框内的灰色基线标记值为零，每个红色滤点（分别表示绿色滤点）表示非负 权重特征（分别为负重特征）。</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t3-p16-xu-large.gif"><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t3-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="表三 - FP 非负 权重特征 （NNWF） 分布"></a></p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t4-p16-xu-large.gif"><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t4-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="表四 - FN 负 权重特征 （NWF） 分布"></a></p>
<p>​ 图11显示，FPs（见图11d）的特征 权重分布与TPs（见图11a）的特征权重分布比TN（见图11c）的特征权重分布更相似，因为大多数特征权重是非负的。另一方面，FN（见图11b）的特征权重分布与TN（见图11c）的分布更相似，而不是TP（见图11a），从某种意义上说，大多数特征权重都低于零。</p>
<p>​ <strong>假阳性。</strong>从 5,789 良性应用开始，DroidEvolver 产生 98 FP（即假阳性率 = 1.70%）。表三显示这些 FP 的非负权重特征的分布。如 表3a 所示，所有这些FP在从其apk文件中提取的所有特征中都拥有超过40%的非负权重特征。虽然他们的真实标签是良性的，90.91%的他们有比负权重特征更多的非负权重特征。在前 100 个显著特征中，表3b 进一步表明，所有这些 <strong>FP 具有比负权重特征更多的非负权重特征</strong>。这些解释了为什么这些应用程序被 DroidEvolver 错误预测。在这些 FP 提取的前 100 个显著特征中，我们发现一些常见的非负权重特征，如：<em>android.-content.pm.PackageManager:getApplicationInfo</em>。这<strong>些 API 通常被恶意软件用于获取有关用户设备的个人信息并检查已安装的应用程序</strong>。</p>
<p>​ <strong>假阴形。</strong>DroidEvolver 在其检测阶段（即 FNR = 6.61%）从 5,777 个恶意应用程序生成 382 个 FN（假阴性）。表四显示这些 FN 的负权重特征的分布。如 表4a 所示，93.33% 的 FN 具有比非负权重特征更多的负权重特征。在前 100 个显著特征中，表 IVb显示 <strong>85% 的 FN 包含的负权重特征多于非负权重特征</strong>。由于大多数特征都与负权重相关，因此除非检查比 API 调用更多的特征，否则 DroidEvolver 很难纠正对这些 FN 的检测。</p>
<h3 id="运行时间表现">4.7、运行时间表现</h3>
<p>​ DroidEvolver 的运行时间表现在检测阶段进行评估，并与具有 4<em>×</em>3.2 Ghz Intel-Cores和 12 GB RAM 的机器上的 MAMADROID 进行比较。对于运行时间评估，DroidEvolver 和 MAMADROID 均在 2011 年训练集中进行初始化、训练，并在 2012 年数据集上进行测试。</p>
<p>​ 表五总结了 DroidEvolver 和 MAMADROID 在平均情况下的运行时间表现：</p>
<p>​ 表5a 所示，DroidEvolver 器的表现瓶颈是预处理器，它分解 apk 文件以获取字形码。DroidEvolver 平均只需约0.05秒进行分类和进化，包括漂移应用识别、应用分类和必要的老化模型聚光化。通过使用可轻松提取为检测特征的 API 调用，并应用在线学习算法快速更新检测模型，DroidEvolver 平均需要 1.37s 才能在检测阶段处理每个未知应用。</p>
<p>​ 表5b所示， MAMADROID 在同一实验环境中的运行时间表现。MAMADROID 的第一步是”调用序列提取“，它使用 Soot 和 FlowDroid 提取 API 调用图，并将提取的 API 调用抽象到其包中。此步骤平均每个应用程序需要 37.29s，这是 MAMADROID 的瓶颈。第二步是建立一个马尔科夫链模型，并构建一个特征向量，这需要平均约0.43秒。最后，MAMADROID 平均需要大约 0.0036s 才能将特征向量分类为良性或恶意。MAMAROID 在检测阶段平均需要 39.15 秒才能处理每个未知应用程序，这比 DroidEvolver 慢 28.58 倍。</p>
<p>​ 如表五所示，<strong>除分类和演化外，DroidEvolver 在所有模块中都明显快于 MAMADROID</strong>。虽然分类未知应用的特征向量和更新老化模型（即 3.22 × 10 + 3s 平均）是轻量级的，它占主导地位，以确定漂移应用程序和相应的老化模型。尽管 DroidEvolver 利用 App数组 在有效性和效率之间取得平衡，但<strong>计算每个未知应用程序的 JI 值需要与 App数组 中包含的所有应用程序进行比较，需要比其他步骤更长时间</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t5-p16-xu-large.gif"><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu.t5-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="Table V- 在数据检测阶段对未知应用进行处理所消耗的时间"></a></p>
<p>​ 然后，在 图12 的<strong>初始/训练阶段和检测阶段</strong>分别评估 DroidEvolver 和 MAMADROID 的运行表现。如 图12a 所示，随着训练集的规模从10,000增加到50,000，DroidEvolver 的初始阶段所需的时间从3s增加到27s。在同一环境中，MAMADROID 的训练阶段从 26 秒增加到 1,207 秒，<strong>比 DroidEvolver 慢 8.67 到 44.70 倍</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu12-p16-xu-large.gif"><img src="https://ieeexplore.ieee.org/mediastore_new/IEEE/content/media/8790377/8806708/8806731/xu12-p16-xu-small.gif" srcset="/img/loading.gif" lazyload alt="Fig. 12: - 运行时间评估"></a></p>
<p>​ 在其<strong>检测阶段</strong>，DroidEvolver 和 MAMADROID 的运行表现与它们处理的应用程序数量是线性的。图12b 显示了他们在检测阶段处理每个应用程序的平均表现，表明 <strong>MAMADROID 明显慢于 DroidEvolver</strong> 。</p>
<p>​ DroidEvolver 的高效在几个方面都取得了成功。</p>
<ul>
<li><strong>首先，DroidEvolver 利用在线学习算法从单个漂移应用程序更新其老化模型，而不是像所有批次基于学习的恶意软件检测系统一样从应用程序集合中学习</strong>。此更新过程使DrodEvolver 能够高效地按顺序处理一系列应用程序。DroidEvolver 不需要定期使用累积数据集进行任何再训练，以跟上应用演变和 Android 框架演变的趋势。</li>
<li><strong>此外，DroidEvolver 不需要真正的标签可用于更新其模型池在检测阶段</strong>。相比之下，大多数现有的恶意软件检测系统依赖于定期模型再训练来更新其检测模型，此类模型再训练需要在原始训练集之外对一组新应用程序进行手动标记，而该新应用受到可用资源的限制。此外，DroidEvolver 应用提取的Android API调用作为检测特征，它可以很容易地从分解字形码中检索，而无需复杂的过程，如那些在 Soot，FlowDroid和 TaintDroid 执行。</li>
<li>最后，<strong>DroidEvolver 应用 App数组</strong>，在不降低检测表现的情况下加快 JI 计算过程。</li>
</ul>
<h3 id="稳健性">4.8、稳健性</h3>
<p>​ <strong>DroidEvolver 可抵御常见的代码混淆，包括标识符重命名、垃圾代码插入、代码重新编序和数据加密</strong>。此类代码混淆可能会避开许多现有的商业反恶意软件工具。</p>
<p>​ <strong>DroidEvolver 具有识别码重命名类型的混淆（如重新签名、重新包装和更改类/字段/字段/方法名称）的弹性</strong>，因为 DroidEvolver 不依赖于特定的应用程序签名或类/字段/方法名称来检测恶意软件，DroidEvolver 还具有对垃圾代码插入的弹性，该插入将垃圾代码段插入应用源代码。如果插入的垃圾代码段不包括 Android API 调用，则此类垃圾代码段不会由 DroidEvolver 提取，因此不会影响 DroidEvolver 的表现。此外，DroidEvolver 是强大的代码重新编序类型的混淆，这改变了模糊应用程序的控制流逻辑。DroidEvolver 是强大的，因为它利用没有控制流逻辑的恶意软件检测。DroidEvolver 也非常适用于数据加密类型的代码混淆，因为它们加密字符串和阵列而不修改应用程序源代码中的原始 API 调用。</p>
<p>​ 我们通过应用 Droid-Chameleon 来模糊 2012 年数据集中随机选择的 100 个恶意应用程序，从而测试 DroidEvolver 的稳健性。DroidChameleon 是 11 种典型混淆技术的框架，包括 （1）标识符重命名：拆解和重新组装、类重命名、方法重命名和字段重命名；（2）垃圾代码插入：垃圾代码插入和 Nop 指令；（3） 代码重新排序：代码重新排序、订单倒转和特征间接插入；（4） 数据加密：字符串加密和阵列加密。我们将 11 种混淆技术中的每一种应用到 100 个选定的恶意应用程序中，生成 1,100 个模糊的应用程序。在 2011 年数据集上初始化后，DroidEvolver 可以成功检测 96% 的模糊应用。对于 11 种混淆技术中的每一项，DroidEvolver 有 <strong>4%的假阴性</strong>。在手动检查了这 44 个假阴性后，我们发现它们都来自四个恶意应用程序。我们进一步测试了 DroidEvolver 在这四个恶意应用程序，发现 DroidEvolver 也判断错误。因此，DroidEvolver 错过了这 44 个模糊的应用程序，不是因为它们被混淆了，而<strong>是因为它们即使没有混淆也错过了。</strong></p>
<p>​ 强攻击者可能会在对抗性采样中小心地制作恶意软件，以逃避恶意软件检测和误导检测模型。对抗性样本制作的一个例子是<strong>将选定的扰动引入某些恶意应用程序的特征向量，以便扰动特征向量上的检测结果为良性</strong>。 考虑一个强大的攻击者谁知道 DroidEvolver进化机制和状态，包括模型池中的所有检测模型，以及应用程序缓冲器中的所有特征向量，在任何时候。此类攻击者可能会在特定时间制作一个特征矢量来逃避恶意软件检测，或创建一组特征矢量来误导 DroidEvolver 的演变。但是，对于此类攻击者来说，从精心制作的特征矢量构建真实世界恶意应用程序仍然具有挑战性，<strong>因为从由精心制作的特征矢量定义的 Android API 固定列表中实现某些目的驱动的恶意特征并非微不足道。它仍然是今后研究如何大规模地进行此类攻击的研究方向。</strong></p>
<h3 id="限制和扩展">4.9、限制和扩展</h3>
<p>​ DroidEvolver 是一种静态分析系统，根据其字形码中包含的一组 Android API 调用检测恶意软件。它无法检测<em>只能根据更复杂的特征（如 API 调用图和字节码语义）检测到的恶意软件</em>。如果在静态分析（如动态加载的恶意代码和运行时间恶意行为）中看不到恶意软件的 API 调用，则可以避开 DroidEvolver 。从<strong>在线学习中继承下来的 DroidEvolver 的另一个局限性是，它容易受到中毒攻击</strong>。在中毒攻击中，攻击者可能会故意为 DroidEvolver 制作初始化数据集，使其无法有效检测某些恶意软件。</p>
<p>​ 为了解决这些限制，<strong>DroidEvolver 可以扩展为使用任何其他检测特征，而不是一组 API 调用</strong>。这种扩展是可行的，因为 DroidEvolver 的核心模块，包括模型池的构建、分类和演化，独立于其他模块中特征向量的生成方式。通过在静态分析中插入 API 调用图和控制流图等更复杂的特征，DroidEvolver 可能会在表现开销上实现更高的回报。只要能够生成并用于此类分析，DroidEvolver 也可以扩展到本地代码分析和动态分析。虽然我们目前的工作重点是设计和评估具有轻量级检测特征的 DroidEvolver 机制，但我们未来的工作将转向将 DroidEvolver 扩展到其他检测特征。</p>
<p>​ 为了阻止中毒攻击，我们<strong>建议将 DroidEvolver 扩展到初始阶段包括消毒模块</strong>。对于初始化数据集中的每个应用程序，消毒模块要求模型池中的每个检测模型根据当前模型结构生成分类标签。如果模型池中的大多数检测模型无法就应用程序的分类标签达成一致，消毒模块可能会认为应用程序”中毒“，并将其从初始化数据集中删除。此消毒过程可以分几轮（每次从零开始）执行，随机重新洗牌初始化数据集。初始化数据集经过消毒后，可以初始化 DroidEvolver 进行恶意软件检测。</p>
<h2 id="相关工作">5、相关工作</h2>
<p>​ 在过去的几年里，Android恶意软件检测引起了学术界和业界的广泛关注。DroidEvolver 更与基于机器学习的 Android 恶意软件检测系统相关。</p>
<p>​ <strong>老化问题。</strong>MAMADROID 是一个Android恶意软件检测系统，由于对包和家庭的抽象 API 调用，该系统能够抵御 Android API 更改。MAMADROID 中的检测模型不会在检测阶段由各个应用程序自动更新，因为它是从批量学习算法构建的。为了保持其恶意软件检测的有效性，可以重新训练一组新的应用程序，然而，这种再训练受制于再训练中使用的应用程序是否提供真实标签。相比之下，DroidEvolver 不需要真正的标签来证明模型在检测阶段的演变。</p>
<p>​ <strong>另一项相关工作是Transcend</strong>，是检测恶意软件分类模型中概念漂移的框架。在 DroidEvolver 中识别漂移应用和老化模型的重要性是由 Transcend 推动的；但是，在超越中为检测概念漂移而提出的统计指标不能直接应用于 DroidEvolver，因为 Transcend 通过将其与所有且仅具有真实标签的训练应用程序进行比较来计算每个测试应用程序的概念漂移指标。概念漂移指标无法捕获每个测试应用程序与检测阶段中没有真实标签的任何新应用有何不同。Transcend 和 DroidEvolver之间的另一个区别是，<strong>Transcend 专注于如何检测概念漂移，而不涵盖如何开发一个减慢，可扩展和强大的恶意软件检测系统，以有效的恶意软件检测随着时间的推移</strong>。</p>
<p>​ <strong>恶意软件检测中的在线学习</strong>。近年来，在线学习算法已应用于 Android 恶意软件检测。例如，DroidOL 和 CASANDRA 使用在线学习算法构建恶意软件检测模型，并根据其 API 调用图对 Android 应用程序进行分类。DroidOL 和 CASANDRA 在收到每个标记应用程序后，都会使用在线学习算法自动重新训练其检测模型，并使用更新的检测模型对未标记的应用程序进行分类。再训练过程要求每个应用程序与其真实标签相关联，而该标签受可用资源的限制。相比之下，DroidEvolver 在检测阶段自动更新其检测模型不需要真正的标签，这回避了在初始化阶段后标记任何应用程序的必要性。<strong>与这些现有方法不同，DroidEvolver 依靠模型池而不是任何单一的在线学习算法来生成其检测结果</strong>。模型池可以帮助检测和减轻任何单一检测模型的偏差，从而产生更可靠的检测结果。</p>
<p>​ <strong>其他恶意软件检测方法</strong>。与DroidEvolver不同，大多数基于学习的恶意软件检测系统依靠频繁的再训练来保持其在恶意软件检测中的有效性，而再训练则在一组标记应用程序上进行，包括超越之前训练集的新应用。下面提供了此类恶意软件检测系统的不完整列表：6ThSense利用三种不同的机器学习技术（即马尔科夫链、朴素贝叶斯和 LMT）来检测与手机传感器相关的恶意行为。StormDroid 使用各种机器学习算法，如 SVM、决策树和朴素贝叶斯，根据已使用的权限、敏感的 API 调用和敏感的 API 调用序列来检测恶意软件。MARVIN 应用线性逻辑回归模型，从静态分析和动态分析中衍生出的大量特征中对 Android 应用程序进行分类。DroidMiner 还使用各种机器学习算法，包括 SVM、决策树、朴素贝叶斯和随机森林来检测敏感 API 名图上的恶意软件。Drebin 根据请求权限、应用组件和可疑的 API 调用将 SVM 应用于恶意软件检测。最后，DroidSIFT 根据上下文 API 依赖性图生成的特征向量执行基于异常的检测和基于签名的检测。</p>
<p>​ 最近，在如何使用深度神经网络进行更好的恶意软件检测方面，我们做出了努力。例如，, DroidDetector 和 Droid-Sec使用 192 个人工工程特征构建了 Android 恶意软件检测的深度置信网络，包括所需的权限、敏感的 API 调用以及从 DroidBox 获得的某些动态行为。Deep4maldroid 构建了来自 Linux 内核系统调用的加权定向图形，并将其用于训练深度神经网络进行 Android 恶意软件检测。Mclaughlin 等人使用深层神经网络根据每个应用程序如何使用 218 dex 指令来检测 Android 恶意软件。DeepRefiner 使用两个具有不同深神经网络的检测层从不同角度检测 Android 恶意软件。FeatureSmith 使用自然语言处理技术从科学文献中生成恶意软件检测特征。</p>
<p>​ 除了基于学习的恶意软件检测系统外，还提出了庞大的基于签名的恶意软件检测系统。例如，Kirin 根据要求的权限检测恶意软件，这些权限违反了某些预先定义的安全规则。</p>
<h2 id="结论">6、结论</h2>
<p>​ 本文介绍了DroidEvolver，一个有效和高效的 Android恶意软件检测系统，可以自动更新自己，以赶上恶意软件和 Android框架的快速演变。与大多数基于学习的恶意软件检测系统不同，DroidEvolver 应用在线学习算法对其具有不断发展的特征集的检测模型进行必要的更新。后者依靠批量学习算法生成具有固定特征集的不可变的检测模型。虽然大多数现有的恶意软件检测系统可以通过对一组带有真实标签的新应用程序进行再训练来更新，但 DroidEvolver 既不需要再训练，也不需要真实标签来更新自己。因此，在资源约束设置中，DroidEvolver 更为实用，因为许多新应用程序无法及时获得真实标签。严格的实验表明，随着时间的推移，DroidEvolver 在准确性和效率方面的表现始终高于恶意软件检测的先进水平，DroidEvolver 也显示强大的对几个典型的代码混淆技术。将来，我们计划在静态分析和动态分析中使用 Android API 调用以外的恶意软件检测特征扩展 DroidEvolver 。最终目标是提高 DroidEvolver 的准确性，以更新真正的标签。我们目前的工作为实现这一最终目标迈出了有希望的第一步。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android-Malware/">Android Malware</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/">论文翻译</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/15/FB2Droid/">
                        <span class="hidden-mobile">FB2Droid - A Novel Malware Family-Based Bagging Algorithm for Android Malware Detection</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"60ac9b2255ef5970b408","clientSecret":"e9bb8e314f7c5f071af9b147335028d648aa9f92","repo":"gitalk_comments","owner":"TennyBUPT","admin":["TennyBUPT"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '594ff18f3bb1d225d2a724a6fc5b0740'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>






  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" srcset="/img/loading.gif" lazyload style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><!-- hexo injector body_end end --></body>
</html>
